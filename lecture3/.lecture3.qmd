---
title: "Lecture 3"
author: "Marc Kaufmann"
date: "10/01/2024"
output: html
editor: 
  markdown: 
    wrap: 72
---

# ggplot recap

Let us draw two datasets on the same plot:

...

This lecture follows the first edition of [Grolemund and Wickham, chapter
5](https://r4ds.had.co.nz/transform.html).

In addition to the `tidyverse`, we will need the `nycflights13` package - you 
can check if you have it by trying to load it via `library(nycflights13)`. 
Otherwise install it (not in this file, in the console).

```{r load-nycflights}
library(tidyverse) 
library(nycflights13)
```

Now explore the data to get a sense:

```{r look-at-nycflights}
flights 
?flights 
View(flights) 
view(flights)
?view
```


Today, we'll cover the first verbs of the `dplyr` (data pliers) package, which 
is part of the `tidyverse`:

- filter(): selecting those rows that we are interested in
- arrange(): ordering the rows
- select(): selecting the columns that we are interested in

After that, we'll cover the remaining ones:

- mutate(): changing the values across rows
- summarise(): creating summary tables 
- group_by(): changing or summarising by groups 

All these commands take as first argument a data frame (or tibble) and return a data frame (or tibble). Together they form the verbs of the tidyverse. This enables a
nice workflow as we will see later.

## Filtering (choosing) rows with filter()

```{r basic-filter}
filter(flights, month = 1)       # Produces an error 
filter(flights, month == 1) 
filter(flights, month == 1, day == 1) 
filter(flights, dep_time == 517) # What format is dep_time in?
```

Note that `dplyr` functions don't change the data frame that you give it. They return a new one.

```{r not-changed}
flights 

# Save the filtered data 
jan1 <- filter(flights, month == 1, day == 1) 
jan1 

# Assign and print, use (varname <- ...) 
(feb1 <- filter(flights, month == 2, day == 1)) 

# Check it really assigned 
feb1
```

## Some notes on comparisons

Before moving on, we need to look at how comparisons behave in R, since it often
affects which rows you get when filtering:

```{r comparisons}
sqrt(2)^2 == 2 
sqrt(4)^2 == 4 
(1/3)*3 == 1 
1/49*49 == 1 
1/(7^9)*7^9 == 1 

# For floating point comparisons, use near() to compare numbers 
near(sqrt(2)^2, 2)
```

The lesson is that you can't rely on "It works because it works for what
I tried". 

**Exercise:** What counts as near? Find out. Can you change it?

## Multiple constraints

You will often want to `filter` on several constraints at the same time. We can
use the `|` ('or'), `&` ('and'), and `!` ('not') operators for this. However, for
'and', we can simply specify multiple constraints by default:

```{r or-and-and}
# Month is january and day is 4
(jan_4a <- filter(flights, month == 1 & day == 4))
(jan_4b <- filter(flights, month == 1, day == 4))

# Month is 1 or 2
(jan_feb <- filter(flights, month == 1 | month == 2)) 

# Month is not january
(not_jan <- filter(flights, !(month == 1)))
```

**Class exercise:** How do we know these actually worked? Should you believe me?

filter(not_jan, month == 1) View(jan_feb) unique(not_jan\$month) \# \$
chooses the column jan \<- filter(flights, month == 1) nrow(flights) ==
nrow(jan) + nrow(not_jan)

(jan_to_june \<- filter(flights, month \<= 6)) jan_to_june_again \<-
filter(flights, month %in% c(1,2,3,4,5,6)) \# Check same number of
observations nrow(jan_to_june) == nrow(jan_to_june_again)

# Class Exercise: What does this do?

mystery_filter \<- filter(flights, !(arr_delay \> 120 \| dep_delay \>
120)) mystery_filter2 \<- filter(flights, arr_delay \<= 120, dep_delay
\<= 120) mystery_filter mystery_filter2

# arr_delay \> 120 OR dep_delay \> 120

# Vote:

# 1. All flights that started and landed 120 minutes late

# 2. All flights that started 120 minutes late or landed 120 minutes late

# 3. All flights that started less than 120 minutes late or landed less than 120 minutes late

# 4. All flights that started and landed less than 120 minutes late

# - (140, 140)

# - (140, 0)

# - (0, 140)

# - (0, 0)

# How to convince ourselves? could use row_number() to add row_number and check the same row numbers are in both filters

# Class Exercise: Get the filter command for number 3 above

# 3. All flights that started less than 120 minutes late or landed less than 120 minutes late

number3 \<- filter(flights, arr_delay \<= 120 \| dep_delay \<= 120)
number3 \<- filter(flights, arr_delay \< 120 \| dep_delay \< 120)

# Class Exercise: get all flights that departed with less than 120 minutes delay,

# but arrived with more than 120 minutes delay.

dep_ok_arr_not \<- filter(flights, dep_delay \<= 120, arr_delay \> 120)

ggplot(data = dep_ok_arr_not, mapping = aes(x = dep_delay)) +
geom_histogram()

# Let's look at the data to see what the departure was for planes that arrived

# late in general

ggplot(data = flights, mapping = aes(x = dep_delay)) + geom_histogram()

# Filter flights by those that had dep_delay \<= 120, then plot histogram

dep_ok \<- filter(flights, dep_delay \<= 120) ggplot(data = dep_ok,
mapping = aes(x = dep_delay)) + geom_histogram()

# NA: Not available

NA \> 5 10 == NA NA == NA FALSE & NA TRUE & NA NA & FALSE

# Nice example from G&W

# Let x be Mary's age. We don't know how old she is.

x \<- NA

# Let y be John's age. We don't know how old he is.

y \<- NA

# Are John and Mary the same age?

x == y

# We don't know!

NA\^0 0 \* NA

is.na(x) df \<- tibble(x = c(1, NA, 3)) df filter(df, x \> 1) filter(df,
x \> 1 \| is.na(x))

## arrange()

flights arrange(flights, year, month, day) arrange(flights, dep_delay)
arrange(flights, desc(dep_delay))

arrange(df, x) arrange(df, desc(x)) arrange(df, desc(is.na(x)), desc(x))
arrange(df, x, desc(x))

# Class exercise (do at home): How can we get the missing values at the top? Use `is.na()`

# Fastest flight

colnames(flights) arrange(df, air_time) arrange(flights, air_time)

# Better ways of getting some special columns

# select()

select(flights, year, month, day)

select(arrange(flights, air_time), air_time, origin, dest)

# That's tedious to write. Hence the pipe.

flights %\>% arrange(air_time) %\>% select(air_time, origin,
destination)

# Or the basic pipe!

flights \|\> arrange(air_time) \|\> select(air_time, origin,
destination)

# Notice that the data doesn't have to be mentioned in the call,

# it gets used as the first argument automatically. Therefore

# the first argument should not be provided

select(flights, year:day) \# Same as .. flights %\>% select(year:day)
colnames(flights)

# dropping cols

select(flights, -(year:day))

# Some helper functions

select(flights, starts_with("arr")) select(flights, -starts_with("arr"))
select(flights, ends_with("hour")) select(flights, -contains("time")) \#
What does the following do? Is that as expected? select(flights,
-contains("time"), starts_with("arr")) \# If you want those that satisfy
both conditions, need two calls flights %\>% select(-contains("time"))
%\>% select(starts_with("arr")) \# For more do ?select

# Function for renaming columns

rename(flights, destination = dest)

# Hard to see if it worked, so...

flights %\>% rename(destination = dest) %\>% select(year:day,
destination)

# Moving some columns to the start

select(flights, origin, dest, everything())

# Class Exercise: What happens if you include a variable multiple times?

# \## Resources

# 

# - If you have no experience coding, this may be helpful: https://rstudio-education.github.io/hopr/
